import { CodeSurfer, CodeSurferColumns, Step } from "code-surfer";
import { vsDark } from "@code-surfer/themes";
import { images } from "./images";
import { future, prism } from "mdx-deck/themes";
import myTheme from "./theme";

export const themes = [future, myTheme, prism];

# E2E & Frontend Testing Strategies

---

## Agenda

1. Testing Theory
1. Testing tools / Cypress
1. Integration tests
1. E2E tests
1. Unit tests

---

# Testing Theory

---

## Why should we test our code?

- To verify that it meets the **requirements**
- To avoid **regressions** after refactoring
- As a **documentation**
- To have a way to test specific cases that are difficult to test manually
- As a **guidance** that
  - force us to think about all cases
  - tells us when we can stop developing a feature

---

## Why aren't we testing our code?

- Writing good tests is **hard**
- We think that testing manually is enough and faster than writing automatic tests
- We think that writing tests is **expensive**

<img src={images.money} />

---

## Why aren't we testing our code?

> ‚ÄúUnit testing is a lot like going to the gym‚Äù

‚Äì [A random guy on Stackoverflow](https://stackoverflow.com/a/69263/9891450)

---

## Test Desiderata (1/2)

- **Isolated** ‚Äî tests should return the same results regardless of the order in which they are run.
- **Composable** ‚Äî if tests are isolated, then I can run 1 or 10 or 100 or 1,000,000 and get the same results.
- **Behavioral** ‚Äî tests should be sensitive to changes in the behavior of the code under test. If the behavior changes, the test result should change.
- **Structure-insensitive** ‚Äî tests should not change their result if the structure of the code changes.
- **Deterministic** ‚Äî if nothing changes, the test result shouldn‚Äôt change.
- **Specific** ‚Äî if a test fails, the cause of the failure should be obvious.

https://medium.com/@kentbeck_7670/test-desiderata-94150638a4b3

---

## Test Desiderata (2/2)

- **Fast** ‚Äî tests should run quickly.
- **Writable** ‚Äî tests should be cheap to write relative to the cost of the code being tested.
- **Readable** ‚Äî tests should be comprehensible for reader, invoking the motivation for writing this particular test.
- **Automated** ‚Äî tests should run without human intervention.
- **Predictive** ‚Äî if the tests all pass, then the code under test should be suitable for production.
- **Inspiring** ‚Äî passing the tests should inspire confidence

https://medium.com/@kentbeck_7670/test-desiderata-94150638a4b3

---

## Test Types: End To End (E2E)

Test the whole application (frontend + backend) like a user (usually from the browser)

---

## Test Types: End To End (E2E)

- ‚úÖ Great **confidence** that everything works as expected
- ‚úÖ Indipendent from the **code structure**
- ‚ùå **Slow**
- ‚ùå Difficult to make them **deterministic**
- ‚ùå Less **specific**
- ‚ùå No **TDD**

---

## Test Types: Unit tests

Test a **unit** of our code in **isolation** from the rest.

What is a unit?! ü§î

---

## Test Types: Unit tests

- ‚úÖ **Fast**
- ‚úÖ Very **specific**
- ‚úÖ Easy to make them **deterministic**
- ‚úÖ **TDD**
- ‚ùå Less **confidence** that everything works as expected
- ‚ùå Tied to the **code structure**
- ‚ùå Often require to **mock** a lot of things

---

<CodeSurfer theme={vsDark}>

```ts file=./code/icon-selector.component.ts title="Angular Component"
```

</CodeSurfer>

---

<CodeSurfer theme={vsDark}>

```ts file=./code/icon-selector.component.spec.ts title="Angular Component Unit Test"
```

```ts 1:25 file=./code/icon-selector.component.spec.ts subtitle="Setup"
```

```ts 10:12 file=./code/icon-selector.component.spec.ts subtitle="Create mock"
```

```ts 14:19 file=./code/icon-selector.component.spec.ts subtitle="Configure testing module"
```

```ts 28:33 file=./code/icon-selector.component.spec.ts subtitle="Test"
```

```ts 35:46 file=./code/icon-selector.component.spec.ts subtitle="Test"
```

</CodeSurfer>

---

## Test Types: Integration tests

Test a group of units and tests their behavior as a whole.

Usually in a frontend application we mean mocking the backend APIs

---

## Test Types: Integration tests

- ‚úÖ Easy to make them **deterministic**
- ‚úÖ Almost indipendent from the **code structure**
- ‚úÖ Require to **mock** only external APIs
- ‚úÖ **TDD**
- ‚ùå Less **confidence** that everything works as expected
- **Faster** than E2E tests, but **slower** than Unit tests
- Less **specific** than Unit tests, but more specific than E2E tests

---

<img src={images.unitIntegration} style={{ height: "80vh" }} />

---

## Testing Pyramid

<img src={images.pyramid1} style={{ height: "70vh" }} />

<small>

https://martinfowler.com/bliki/TestPyramid.html

https://testing.googleblog.com/2015/04/just-say-no-to-more-end-to-end-tests.html

</small>

---

## Testing Trophy

<img src={images.pyramid2} style={{ height: "70vh" }} />

https://kentcdodds.com/blog/write-tests

---

## Other test types

- Smoke tests
- Visual regression tests ([Percy](https://percy.io/), [Applitools](https://applitools.com/))
- Load tests
- Penetration tests
- Contract testing
- Mutation tests ([Stryker](https://stryker-mutator.io/))
- Property based tests ([Fast-check](https://github.com/dubzzz/fast-check))
- ...

---

# Testing tools / Cypress

---

## Testing Tools

<img src={images.testingTools} />

---

## [Cypress](https://www.cypress.io/)

- ‚úÖ Open Source
- ‚úÖ Test Runner in the browser
- ‚úÖ Great documentation
- ‚úÖ Great ecosystem (guides, plugins, resources)
- ‚ùå Not crossbrowser (only Chrome, Edge and Firefox)
- ‚ùå Some important issues not yet resolved
- ‚ùå Some features are difficult to set up (Typescript, code coverage)

---

## Cypress Directory structure

```
‚îú‚îÄ‚îÄ cypress
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ fixtures <--------- Mocked Data
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ integration <------ Our tests
‚îÇ¬†¬† ‚îú‚îÄ‚îÄ plugins <---------- Plugins/extensions
‚îÇ¬†¬† ‚îî‚îÄ‚îÄ support <---------- Utilities and custom commands
‚îî‚îÄ‚îÄ cypress.json <--------- Cypress configuration
```

---

## Configure Cypress

```json
// cypress.json
{
  "baseUrl": "http://localhost:4200"
}
```

---

## Launch Cypress

```json
// package.json
{
    "scripts": {
        ...,
        "cy:open": "cypress open",
        "cy:run": "cypress run"
    }
}
```

---

<CodeSurfer theme={vsDark}>

```ts file=./code/test-structure.ts title="Test file structure"
```

```ts 3:3 file=./code/test-structure.ts subtitle="Group"
```

```ts 4:18 file=./code/test-structure.ts subtitle="Hooks"
```

```ts 20:30 file=./code/test-structure.ts subtitle="Tests"
```

</CodeSurfer>

---

<CodeSurfer theme={vsDark}>

```ts file=./code/cypress-first-test.ts title="Cypress test example"
```

```ts 3:3 file=./code/cypress-first-test.ts
```

```ts 5:7 file=./code/cypress-first-test.ts
```

```ts 9:11 file=./code/cypress-first-test.ts
```

```ts 13:13 file=./code/cypress-first-test.ts
```

```ts 15:15 file=./code/cypress-first-test.ts
```

```ts 17:17 file=./code/cypress-first-test.ts
```

</CodeSurfer>

---

## Chains of commands

- Cypress is based on [chains of commands](https://docs.cypress.io/guides/core-concepts/introduction-to-cypress.html#Chains-of-Commands)
  ```ts
  cy.get("input.post-title").clear().type("My First Post");
  ```
- Some commands can be chained, others cannot
- Asynchronous (~ Promises) with automatic waiting

---

<CodeSurfer theme={vsDark}>

```ts title="Assertions" subtitle="Single Assertion on an element"
cy.get("button").click().should("have.class", "active");
```

```ts title="Assertions" subtitle="Negative Assertion on an element"
cy.get("#modal").should("not.exist");
```

```ts title="Assertions" subtitle="Multiple Assertions on an element"
cy.get("#header a")
  .should("have.class", "active")
  .and("have.attr", "href", "/users");
```

```ts title="Assertions" subtitle="Single assertion on an object"
cy.request("/users/1").its("body").should("deep.eq", { name: "Jane" });
```

```ts title="Assertions" subtitle="Explicit form"
cy.get("tbody tr:first").should(($tr) => {
  expect($tr).to.have.class("active");
  expect($tr).to.have.attr("href", "/users");
});
```

</CodeSurfer>

---

## Selecting Elements

1. Prefer selectors based on user perspective like:
   - `cy.findByLabelText`, `cy.findByPlaceholderText`, `cy.findByTitle`
     from [Cypress Testing Library](https://testing-library.com/docs/cypress-testing-library/intro)
   - `cy.contains` from Cypress
2. If not possible, use `cy.findByTestId` from Cypress Testing Library
3. If not possible, use CSS selectors

---

<CodeSurferColumns themes={[vsDark, vsDark]}>

<Step subtitle="findByLabelText">

```html
<!-- page.html -->

<label for="username">Username</label>
<input id="username" />
```

```ts
// spec.ts

cy.findByLabelText(/username/i);
```

</Step>

<Step subtitle="findByTitle">

```html
<!-- page.html -->

<button type="button" class="btn btn-danger" title="Delete">
  <i class="fa fa-trash"></i>
</button>
```

```ts
// spec.ts

cy.findByTitle(/delete/i);
```

</Step>

<Step subtitle="findByTestId">

```html
<!-- page.html -->

<div data-testid="chart-container">
  <!-- ... -->
</div>
```

```ts
// spec.ts

cy.findByTestId("chart-container");
```

</Step>

<Step subtitle="CSS selector">

```html 3:5
<!-- page.html -->

<div class="modal-body">
  <!-- ... -->
</div>
```

```ts
// spec.ts

cy.get(".modal-body");
```

</Step>

</CodeSurferColumns>

---

<CodeSurfer theme={vsDark}>

```ts title="Tip: Share code between tests and between app and tests"
// cypress/support/selectors.ts
export const MODAL_BODY_CLASS = ".modal-body";

// cypress/integration/my-test.ts
import { MODAL_BODY_CLASS } from "cypress/support/selectors.ts";

cy.get(MODAL_BODY_CLASS);
```

</CodeSurfer>

---

<CodeSurfer theme={vsDark}>

```ts title="Tip: Share code between tests and between app and tests"
// cypress/support/utils.ts
export function fillUsername(username: string) {
  cy.findByLabelText(/username/i)
    .clear()
    .type(username);
}

// cypress/integration/my-test.ts
import { fillUsername } from "cypress/support/utils.ts";

fillUsername("bender");
```

</CodeSurfer>

---

## Tip: Custom Commands

We can create [custom commands](https://docs.cypress.io/api/cypress-api/custom-commands.html), and use them in a Cypress Chain.

Useful if the code is reused a lot in our tests and it is more comfortable to use it inside a chain, or if we want to control the output in the test runner.

Check also [cypress-pipe](https://github.com/NicholasBoll/cypress-pipe) plugin.

---

<CodeSurfer theme={vsDark}>

```ts title="Tip: Restrict Scope with within"
cy.get(".modal-body").within(() => {
  // ...
});
```

</CodeSurfer>

---

<CodeSurferColumns themes={[vsDark, vsDark]}>
 
<Step title="Tip: Use the force">

<div>
  <div style={{ color: "#F00", margin: "5rem 0", fontSize: "2rem" }}>
    This element ‚Äò&lt;input&gt;‚Äô is not visible because its content is being
    clipped by one of its parent elements, which has a CSS property of overflow:
    ‚Äòhidden‚Äô, ‚Äòscroll‚Äô or ‚Äòauto‚Äô
  </div>
  <img src={images.force} style={{ width: "100%" }} />
</div>

```ts
cy.get("input").type("meeeeow", { force: true });
```

</Step>

</CodeSurferColumns>

---

## [Tip: Await, don't sleep](https://docs.cypress.io/guides/references/best-practices.html#Unnecessary-Waiting)

‚ùå Anti-Pattern: Waiting for arbitrary time periods using cy.wait(Number).

‚úÖ Best Practice: Use route aliases or assertions to guard Cypress from proceeding until an explicit condition is met.

Check also [Cypress Wait Until Plugin](https://github.com/NoriSte/cypress-wait-until)

---

<CodeSurfer theme={vsDark}>

```ts title="Await, don't sleep"
cy.server();
cy.route("GET", /users/, [{ name: "Maggy" }, { name: "Joan" }]);
cy.get("#fetch").click();
cy.wait(4000); // <--- this is unnecessary
cy.get("table tr").should("have.length", 2);
```

```ts
cy.server();
cy.route("GET", /users/, [{ name: "Maggy" }, { name: "Joan" }]).as("getUsers");
cy.get("#fetch").click();
cy.wait("@getUsers"); // <--- wait explicitly for this route to finish
cy.get("table tr").should("have.length", 2);
```

</CodeSurfer>

---

## [TIP: Clean state in the beforeEach hook](https://docs.cypress.io/guides/references/best-practices.html#Using-after-or-afterEach-hooks)

‚ùå Anti-Pattern: Using after or afterEach hooks to clean up state.

‚úÖ Best Practice: Clean up state before tests run.

---

# Integration tests

---

## Integration tests

- [Stub network requests](https://docs.cypress.io/guides/guides/network-requests.html) to backend APIs and Keycloak.
- Test are completely indipendent from external resources, they are fast and we can easily test edge cases

---

## Stubbing requests

```typescript
cy.server();

// method, path, response
cy.route("POST", "/users", { result: "Ok" });

// fixtures (implicit GET method)
cy.route("/users/*", "fx:users/user1.json");
```

---

## Create fixture

- Copy response from existing API:<br />
  <img src={images.chromeRequest} />
- Use [OpenAPI Mock Generator](https://github.com/Fredx87/openapi-mock-generator)

---

## Keycloak

Fake login using [cypress-keycloak-commands](https://github.com/Fredx87/cypress-keycloak-commands)

```ts
describe("Feature", () => {
  beforeEach(() => {
    cy.kcFakeLogin("user", "pageToVisit");
  });
});
```

---

## Keycloak

```json
// cypress/fixtures/users/user.json
{
  "fakeLogin": {
    "access_token": "...",
    "refresh_token": "...",
    "id_token": "...",
    "account": { ... }
  }
}
```

---

<CodeSurfer theme={vsDark}>

```ts file=./code/integration1.ts title="Integration test example"
```

```ts 3:8 file=./code/integration1.ts title="Integration test example" subtitle="Arrange"
```

```ts 10:10 file=./code/integration1.ts title="Integration test example" subtitle="Act"
```

```ts 12:12 file=./code/integration1.ts  title="Integration test example" subtitle="Assert"
```

</CodeSurfer>

---

<CodeSurfer theme={vsDark}>

```ts file=./code/integration2.ts title="Integration test example - put"
```

```ts 2:9 file=./code/integration2.ts title="Integration test example - put"
```

```ts 12:21 file=./code/integration2.ts title="Integration test example - put"
```

```ts 23:27 file=./code/integration2.ts  title="Integration test example - put"
```

</CodeSurfer>

---

# E2E tests

---

## E2E Tests

- Test the whole system (frontend, backend, Keycloak, DB, ...)
- Mock only external parts (e.g. SMTP Server, Devices, External APIs...)
- Need the possiblity to have a clean state before tests execution

---

## Clean state

There are many ways, depending on the project. Examples:

- For testing **before the deploy**
  - Setup a clean environment (even a local one with `docker-compose`)
  - Script for put the DB in a clean state before each test
- If not possible, E2E tests can be run on the **deployed version** on the dev environment
  - Have a way to have a clean state before each test
  - e.g. in a multi-tenant application have a "Test" tenant and delete all linked records before each test

---

## Keycloak

Real login using [cypress-keycloak-commands](https://github.com/Fredx87/cypress-keycloak-commands)

```ts
describe("Feature", () => {
  beforeEach(() => {
    cy.kcLogout();
    cy.kcLogin("user");
    cy.visit("/");
  });
});
```

---

## Keycloak

```json
// cypress/fixtures/users/user.json
{
  "username": "user",
  "password": "password"
}
```

---

## Cypress task

Create a [Cypress task](https://docs.cypress.io/api/commands/task.html) running in Node

```ts
// plugins/index.js
module.exports = (on, config) => {
  on('task', {
    cleanupDb() { ... }
  })
}
```

---

## Using task

```ts
// integration/feature/sub-feature.e2e.spec.ts
describe("Feature / E2E", () => {
  beforeEach(() => {
    cy.task("cleanupDb");
  });
});
```

---

<CodeSurfer theme={vsDark}>

```ts file=./code/e2e1.ts title="E2E test - complete flow"
```

```ts 2:9 file=./code/e2e1.ts title="E2E test - complete flow"
```

```ts 11:23 file=./code/e2e1.ts title="E2E test - complete flow"
```

</CodeSurfer>

---

<CodeSurfer theme={vsDark}>

```ts file=./code/e2e2.ts title="E2E test - different steps"
```

```ts 2:9 file=./code/e2e2.ts title="E2E test - different steps"
```

```ts 6:6 file=./code/e2e2.ts title="E2E test - different steps"
```

```ts 11:19 file=./code/e2e2.ts title="E2E test - different steps"
```

```ts 21:40 file=./code/e2e2.ts title="E2E test - different steps"
```

</CodeSurfer>

---

# Unit tests

---

## Unit tests

- Test a function, a class, or a component in **isolation**
- For testing **complex business logic** in a more convenient way, or for logic that cannot be tested in another way (e.g. charts)
- For testing **shared components** that are indipendent from services

---

<CodeSurferColumns themes={[vsDark, vsDark]}>

<Step title="Unit test example">

```ts
// src/calculator.ts
export function sum(a: number, b: number): number {
  return a + b;
}
```

```ts
// cypress/integration/calculator.test.ts
import { sum } from "../../src/calculator.ts";

it("should sum numbers", function () {
  expect(sum(1, 2)).to.eq(3);
});
```

</Step>

</CodeSurferColumns>

---

## Pure functions

- Isolate the logic under test in a **pure function**
- In application code, run side effects (e.g. HTTP calls, translations, ...) outside the function and pass the result
  to the function (**functional core, imperative shell** pattern)
- If not possibile (for example if you need to make an HTTP call based on a condition),
  create a function to make the HTTP call and pass it to the pure function

---

## Links

- https://testingjavascript.com/
- https://github.com/goldbergyoni/javascript-testing-best-practices
- https://glebbahmutov.com/blog/
- https://kentcdodds.com/blog/
- https://github.com/NoriSte/ui-testing-best-practices
